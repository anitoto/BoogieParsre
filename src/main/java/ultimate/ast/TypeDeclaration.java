/* TypeDeclaration -- Automatically generated by TreeBuilder (2025-06-30T08:11Z) */

package ultimate.ast;

import java.util.ArrayList;
import java.util.List;

import ultimate.ast.BoogieASTNode;
import ultimate.models.ILocation;
/**
 * A type declaration declares/defines a new type. There are two
 * kinds of type declarations, those declaring unspecified types
 * (synonym is null) and those giving an existing type a new name
 * (synonym is the existing type).<br/>
 * 
 * A type can have type parameters (typeParams), e.g., you can
 * define array types as follows.
 * <pre>type Array Index Elem = [Index]Elem;</pre>
 * Then &ldquo;Array&rdquo; itself is not a type, but
 * &ldquo;Array int real&rdquo; is a type and its definition is
 * <code>[int]real</code>.
 */
public class TypeDeclaration extends Declaration {
    private static final long serialVersionUID = 1L;
    private static final java.util.function.Predicate<BoogieASTNode> VALIDATOR = 
			BoogieASTNode.VALIDATORS.get(TypeDeclaration.class);
    /**
     * True, iff the type was declared as finite. A finite type
     * is a type that is not guaranteed to be infinite. This should
     * only be used for unspecified types, i.e., getSynonym() is null.
     */
    boolean isFinite;

    /**
     * The name of the type that is declared or defined.
     */
    String identifier;

    /**
     * An array containing the names of the type parameters. If the
     * type does not have parameters, this is an empty array. For
     * unspecified types, the contents of the array has no semantics.
     * For defined types, the synonym may reference these type
     * parameters using a NamedType with zero arguments.
     */
    String[] typeParams;

    /**
     * The type definition. This is null for unspecified types.
     */
    ASTType synonym;

    /**
     * The constructor taking initial values.
     * @param loc the location of this node
     * @param attributes the implementation specific attributes of this declaration.
     * @param isFinite true, iff the type was declared as finite.
     * @param identifier the name of the type that is declared or defined.
     * @param typeParams an array containing the names of the type parameters.
     */
    public TypeDeclaration(ILocation loc, Attribute[] attributes, boolean isFinite, String identifier, String[] typeParams) {
        super(loc, attributes);
        this.isFinite = isFinite;
        this.identifier = identifier;
        this.typeParams = typeParams;
        assert VALIDATOR == null || VALIDATOR.test(this) : "Invalid TypeDeclaration: " + this;
    }

    /**
     * The constructor taking initial values.
     * @param loc the location of this node
     * @param attributes the implementation specific attributes of this declaration.
     * @param isFinite true, iff the type was declared as finite.
     * @param identifier the name of the type that is declared or defined.
     * @param typeParams an array containing the names of the type parameters.
     * @param synonym the type definition.
     */
    public TypeDeclaration(ILocation loc, Attribute[] attributes, boolean isFinite, String identifier, String[] typeParams, ASTType synonym) {
        super(loc, attributes);
        this.isFinite = isFinite;
        this.identifier = identifier;
        this.typeParams = typeParams;
        this.synonym = synonym;
        assert VALIDATOR == null || VALIDATOR.test(this) : "Invalid TypeDeclaration: " + this;
    }

    /**
     * Returns a textual description of this object.
     */
    public String toString() {
        StringBuffer sb = new StringBuffer();
        sb.append("TypeDeclaration").append('[');
        sb.append(isFinite);
        sb.append(',').append(identifier);
        sb.append(',');
        if (typeParams == null) {
            sb.append("null");
        } else {
            sb.append('[');
            for(int i1 = 0; i1 < typeParams.length; i1++) {
                if (i1 > 0) sb.append(',');
                    sb.append(typeParams[i1]);
            }
            sb.append(']');
        }
        sb.append(',').append(synonym);
        return sb.append(']').toString();
    }

    /**
     * Checks true, iff the type was declared as finite. A finite type
     * is a type that is not guaranteed to be infinite. This should
     * only be used for unspecified types, i.e., getSynonym() is null.
     * @return true, iff the type was declared as finite.
     */
    public boolean isFinite() {
        return isFinite;
    }

    /**
     * Gets the name of the type that is declared or defined.
     * @return the name of the type that is declared or defined.
     */
    public String getIdentifier() {
        return identifier;
    }

    /**
     * Gets an array containing the names of the type parameters. If the
     * type does not have parameters, this is an empty array. For
     * unspecified types, the contents of the array has no semantics.
     * For defined types, the synonym may reference these type
     * parameters using a NamedType with zero arguments.
     * @return an array containing the names of the type parameters.
     */
    public String[] getTypeParams() {
        return typeParams;
    }

    /**
     * Gets the type definition. This is null for unspecified types.
     * @return the type definition.
     */
    public ASTType getSynonym() {
        return synonym;
    }

    public List<BoogieASTNode> getOutgoingNodes() {
        List<BoogieASTNode> children = super.getOutgoingNodes();
        children.add(synonym);
        return children;
    }

    public void accept(GeneratedBoogieAstVisitor visitor) {
        if (visitor.visit((Declaration)this)) {
            //visit parent types higher up if necessary
        } else {
            return;
        }
        if (visitor.visit(this)) {
            if(synonym!=null){
                synonym.accept(visitor);
            }
            if(attributes!=null){
                for (Attribute elem : attributes) {
                    elem.accept(visitor);
                }
            }
        }
    }

    public Declaration accept(GeneratedBoogieAstTransformer visitor) {
        Declaration node = visitor.transform(this);
        if(node != this){
            return node;
        }

            ASTType newsynonym = null;
        if(synonym != null){
            newsynonym = (ASTType)synonym.accept(visitor);
        }
        boolean isChanged=false;
            ArrayList<Attribute> tmpListnewattributes = new ArrayList<>();
        if(attributes != null){
            for(Attribute elem : attributes){
                Attribute newattributes = (Attribute)elem.accept(visitor);
                isChanged = isChanged || newattributes != elem;
                tmpListnewattributes.add(newattributes);
            }
        }
        if(isChanged || synonym != newsynonym){
            return new TypeDeclaration(loc, tmpListnewattributes.toArray(new Attribute[0]), isFinite, identifier, typeParams, newsynonym);
        }
        return this;
    }
}
